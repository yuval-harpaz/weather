<!DOCTYPE html>
<html lang="he" dir="rtl">

<head>
    <meta charset="UTF-8">
    <title>×ª×—×–×™×ª ××–×’ ××•×•×™×¨ - 4 ×™××™×</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="logo.jpg">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css" />
    <!-- Common map styles -->
    <link rel="stylesheet" href="style.css" />
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Assistant', sans-serif;
            margin: 0;
            padding: 0;
        }

        .leaflet-tooltip.compact-tooltip {
            background-color: white !important;
            border: none !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15) !important;
            padding: 0 !important;
            font-family: 'Assistant', sans-serif;
            pointer-events: none !important;
        }

        .leaflet-tooltip-right.compact-tooltip::before {
            border-right-color: white !important;
            left: -10px !important;
        }

        .leaflet-tooltip-left.compact-tooltip::before {
            border-left-color: white !important;
            right: -10px !important;
        }

        .leaflet-tooltip.compact-tooltip .forecast-grid {
            border-radius: 8px;
            overflow: hidden;
        }

        .forecast-grid {
            display: flex;
            padding: 2px 4px;
            gap: 2px;
            background: #f8fafc;
        }

        .forecast-day {
            flex: 1;
            text-align: center;
            padding: 2px 2px;
            border-radius: 8px;
            transition: background 0.2s;
            min-width: 0;
        }

        .forecast-day:hover {
            background: #e0e7ff;
        }

        .day-header {
            display: flex;
            justify-content: center;
            align-items: baseline;
            gap: 4px;
            margin-bottom: 0px;
        }

        .day-name {
            font-size: 0.9em;
            font-weight: 700;
            color: #1e40af;
        }

        .day-date {
            font-size: 0.7em;
            color: #64748b;
        }

        .weather-emoji {
            font-size: 1.5em;
            margin: 0px 0;
        }

        .weather-desc {
            font-size: 0.72em;
            color: #475569;
            margin-bottom: 6px;
            line-height: 1.2;
            min-height: 2em;
        }

        .temp-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
            font-size: 0.9em;
        }

        .temp-max {
            font-weight: 700;
            color: #dc2626;
        }

        .temp-min {
            font-weight: 600;
            color: #2563eb;
        }

        .temp-separator {
            color: #94a3b8;
            font-weight: 400;
        }

        /* Legend styles */
        .info.legend {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            line-height: 1.5;
            font-weight: 600;
            color: #475569;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: right;
            margin-left: 8px;
            opacity: 0.85;
            border-radius: 4px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            font-family: 'Assistant', sans-serif;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 1.1em;
            color: #475569;
            font-weight: 600;
        }

        .error-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fef2f2;
            color: #991b1b;
            padding: 24px 32px;
            border-radius: 12px;
            font-size: 1.1em;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            direction: rtl;
        }

        @media (max-width: 500px) {
            .leaflet-popup-content {
                min-width: 220px;
                max-width: 290px;
            }

            .popup-header {
                font-size: 1em;
                padding: 10px 12px;
            }

            .forecast-grid {
                padding: 4px;
            }

            .forecast-day {
                padding: 6px 2px;
            }

            .weather-emoji {
                font-size: 1.3em;
            }

            .day-name {
                font-size: 0.9em;
            }

            .temp-max {
                font-size: 1em;
            }

            .temp-min {
                font-size: 0.85em;
            }

            .weather-desc {
                font-size: 0.65em;
            }
        }
    </style>
</head>

<body>
    <div id="loading" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">×˜×•×¢×Ÿ ×ª×—×–×™×ª...</div>
    </div>

    <div id="floating-title" style="flex-direction: row; justify-content: center; gap: 20px;">
        <a href="index.html" class="home-btn">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
            <span>×“×£ ×”×‘×™×ª</span>
        </a>
        <h1 style="margin: 0;">
            <img src="logo.jpg" alt="Icon" class="title-icon">
            ×ª×—×–×™×ª ××–×’ ××•×•×™×¨ - 4 ×™××™×
        </h1>
        <div class="data-source" style="margin-top: 0;">
            <span>× ×ª×•× ×™× ×</span>
            <a href="https://ims.gov.il/en/data_gov" target="_blank" rel="noopener">
                <img src="https://ims.gov.il/themes/imst/ims/images/logo.jpg" alt="IMS" class="ims-logo">
            </a>
        </div>
    </div>
    <div id="map"></div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <script>
        // Initialize map centered on Israel
        const map = L.map('map').setView([31.5, 35.0], 8);

        // Tile layer
        L.tileLayer('https://cdnil.govmap.gov.il/xyz/heb/{z}/{x}/{y}.png', {
            attribution: 'Â© ×”××¨×›×– ×œ××™×¤×•×™ ×™×©×¨××œ www.govmap.gov.il'
        }).addTo(map);

        // Hebrew day-of-week symbols: Sunday=× ... Saturday=×©
        const hebrewDays = ['×', '×‘', '×’', '×“', '×”', '×•', '×©'];
        const openCities = ['×™×¨×•×©×œ×™×', '×ª×œ ××‘×™×‘', '×‘××¨ ×©×‘×¢', '×—×™×¤×”', '××™×œ×ª', '×¦×¤×ª', '××¦×¤×” ×¨××•×Ÿ'];
        let markers = [];
        let firstClick = true;

        // Weather code â†’ emoji mapping
        const weatherEmoji = {
            1010: 'ğŸŒªï¸',  // Sandstorms
            1020: 'â›ˆï¸',   // Thunderstorms
            1060: 'ğŸŒ¨ï¸',  // Snow
            1070: 'ğŸŒ¨ï¸',  // Light Snow
            1080: 'ğŸŒ¨ï¸',  // Sleet
            1140: 'ğŸŒ§ï¸',  // Rainy
            1160: 'ğŸŒ«ï¸',  // Fog
            1220: 'â›…',   // Partly cloudy
            1230: 'â˜ï¸',   // Cloudy
            1250: 'â˜€ï¸',   // Clear
            1260: 'ğŸ’¨',   // Windy
            1270: 'ğŸŒ¡ï¸',  // Muggy
            1300: 'â„ï¸',   // Frost
            1310: 'ğŸ”¥',   // Hot
            1320: 'ğŸ¥¶',   // Cold
            1510: 'ğŸŒŠ',   // Stormy
            1520: 'â„ï¸',   // Heavy Snow
            1530: 'ğŸŒ¤ï¸',  // Partly cloudy possible rain
            1540: 'ğŸŒ¥ï¸',  // Cloudy possible rain
            1560: 'ğŸŒ¦ï¸',  // Cloudy light rain
            1570: 'ğŸ˜¶â€ğŸŒ«ï¸', // Dust
            1580: 'ğŸ”¥',   // Hot Extremely
            1590: 'ğŸ¥¶',   // Extremely Cold
        };

        // Temperature â†’ color gradient (blue=cold â†’ red=hot)
        function tempColor(temp) {
            const t = Math.max(0, Math.min(45, temp));
            const ratio = t / 45;
            const r = Math.round(30 + 225 * ratio);
            const g = Math.round(100 + 80 * (1 - Math.abs(ratio - 0.5) * 2));
            const b = Math.round(220 - 190 * ratio);
            return `rgb(${r},${g},${b})`;
        }

        // Format date as DD/MM
        function fmtDate(dateStr) {
            const parts = dateStr.split('-');
            return parts[2] + '/' + parts[1];
        }

        // Fetch weather codes CSV and XML forecast data
        Promise.all([
            fetch('https://raw.githubusercontent.com/yuval-harpaz/weather/main/data/weather_code.csv').then(r => r.text()),
            fetch('https://quiet-glitter-2b69.yuvharpaz.workers.dev').then(r => r.arrayBuffer())
        ]).then(([codesCsv, xmlBuffer]) => {
            // Parse weather codes
            const codesData = Papa.parse(codesCsv, { header: true, skipEmptyLines: true }).data;
            const weatherCodes = {};
            codesData.forEach(row => {
                weatherCodes[row.Code] = { he: row['××–×’ ×”××•×•×™×¨'], en: row.Weather };
            });

            // Decode ISO-8859-8 (Hebrew)
            const decoder = new TextDecoder('iso-8859-8');
            const xmlText = decoder.decode(new Uint8Array(xmlBuffer));

            // Parse XML
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            const locations = xmlDoc.querySelectorAll('Location');

            const cities = [];

            locations.forEach(loc => {
                const meta = loc.querySelector('LocationMetaData');
                const nameEng = meta.querySelector('LocationNameEng').textContent;
                const nameHeb = meta.querySelector('LocationNameHeb').textContent;
                const lat = parseFloat(meta.querySelector('DisplayLat').textContent);
                const lon = parseFloat(meta.querySelector('DisplayLon').textContent);

                const timeUnits = loc.querySelectorAll('TimeUnitData');
                const days = [];

                timeUnits.forEach(tu => {
                    const date = tu.querySelector('Date').textContent;
                    const elements = tu.querySelectorAll('Element');
                    const dayData = { date };

                    elements.forEach(el => {
                        const name = el.querySelector('ElementName').textContent;
                        const value = el.querySelector('ElementValue').textContent;
                        if (name === 'Maximum temperature') dayData.max = parseInt(value);
                        if (name === 'Minimum temperature') dayData.min = parseInt(value);
                        if (name === 'Weather code') dayData.weatherCode = value;
                    });

                    // Only include days that have at least a weather code or max temp
                    if (dayData.weatherCode || dayData.max !== undefined) {
                        days.push(dayData);
                    }
                });

                // Take up to 4 days that have max temperature
                const forecastDays = days.filter(d => d.max !== undefined).slice(0, 4);

                if (forecastDays.length > 0) {
                    cities.push({ nameEng, nameHeb, lat, lon, days: forecastDays });
                }
            });

            // Add markers
            cities.forEach(city => {
                // Next day's max temp for marker color
                const nextDayMax = city.days[0] ? city.days[0].max : 25;
                const color = tempColor(nextDayMax);

                const marker = L.circleMarker([city.lat, city.lon], {
                    radius: 8,
                    fillColor: color,
                    color: '#fff',
                    weight: 1.5,
                    opacity: 1,
                    fillOpacity: 0.9
                }).addTo(map);

                markers.push({ marker, nameHeb: city.nameHeb, days: city.days });

                // Build forecast HTML
                let forecastHTML = '<div class="forecast-grid">';
                city.days.forEach(day => {
                    const d = new Date(day.date + 'T00:00:00');
                    const daySymbol = hebrewDays[d.getDay()];
                    const emoji = weatherEmoji[day.weatherCode] || 'ğŸŒ¡ï¸';

                    forecastHTML += `
            <div class="forecast-day">
              <div class="day-header">
                <span class="day-name">${daySymbol}</span>
                <span class="day-date">${fmtDate(day.date)}</span>
              </div>
              <div class="weather-emoji">${emoji}</div>
              <div class="temp-row">
                <span class="temp-min">${day.min !== undefined ? day.min : '-'}</span>
                <span class="temp-separator">-</span>
                <span class="temp-max">${day.max !== undefined ? day.max : '-'}</span>
              </div>
            </div>`;
                });
                forecastHTML += '</div>';

                const isPermanent = openCities.some(name => city.nameHeb.includes(name));

                marker.bindTooltip(forecastHTML, {
                    permanent: isPermanent,
                    direction: 'right',
                    className: 'compact-tooltip',
                    offset: [165, 0],
                    opacity: 1,
                    interactive: false,
                    sticky: false
                });

                marker.on('click', function (e) {
                    // Make all markers non-permanent for hover behavior
                    markers.forEach(m => {
                        const tt = m.marker.getTooltip();
                        if (tt) {
                            const content = tt.getContent();
                            m.marker.unbindTooltip();
                            m.marker.bindTooltip(content, {
                                permanent: false,
                                direction: 'right',
                                className: 'compact-tooltip',
                                offset: [165, 0],
                                opacity: 1,
                                interactive: false,
                                sticky: false
                            });
                        }
                    });

                    // Make the clicked marker permanent so it stays open
                    const clickedContent = marker.getTooltip() ? marker.getTooltip().getContent() : forecastHTML;
                    marker.unbindTooltip();
                    marker.bindTooltip(clickedContent, {
                        permanent: true,
                        direction: 'right',
                        className: 'compact-tooltip',
                        offset: [165, 0],
                        opacity: 1,
                        interactive: false,
                        sticky: false
                    });
                    marker.openTooltip();
                    firstClick = false;
                });
            });

            // Add legend
            const legend = L.control({ position: 'bottomleft' });
            legend.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info legend');
                const grades = [10, 20, 30, 40];
                div.innerHTML = '<div>×˜××¤\' ××§×¡×™××•×</div>';
                for (let i = 0; i < grades.length; i++) {
                    div.innerHTML +=
                        '<i style="background:' + tempColor(grades[i]) + '"></i> ' +
                        grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+');
                }
                return div;
            };
            legend.addTo(map);

            // Hide loading
            document.getElementById('loading').style.display = 'none';

        }).catch(err => {
            console.error('Error loading forecast data:', err);
            document.getElementById('loading').innerHTML =
                `<div class="error-msg">×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×”×ª×—×–×™×ª<br><small>${err.message}</small></div>`;
        });
    </script>

</body>

</html>