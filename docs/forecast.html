<!DOCTYPE html>
<html lang="he" dir="rtl">

<head>
    <meta charset="UTF-8">
    <title>×ª×—×–×™×ª ××–×’ ××•×•×™×¨ - 4 ×™××™×</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="logo.jpg">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css" />
    <!-- Common map styles -->
    <link rel="stylesheet" href="style.css" />
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Assistant', sans-serif;
            margin: 0;
            padding: 0;
        }

        .leaflet-tooltip.compact-tooltip {
            background-color: white !important;
            border: none !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15) !important;
            padding: 0 !important;
            font-family: 'Assistant', sans-serif;
            pointer-events: none !important;
        }

        .leaflet-tooltip-right.compact-tooltip::before {
            border-right-color: white !important;
            left: -10px !important;
        }

        .leaflet-tooltip-left.compact-tooltip::before {
            border-left-color: white !important;
            right: -10px !important;
        }

        .leaflet-tooltip.compact-tooltip .forecast-grid {
            border-radius: 8px;
            overflow: hidden;
        }

        .forecast-grid {
            display: flex;
            padding: 2px 4px;
            gap: 2px;
            background: #f8fafc;
        }

        .forecast-day {
            flex: 1;
            text-align: center;
            padding: 2px 2px;
            border-radius: 8px;
            transition: background 0.2s;
            min-width: 0;
        }

        .forecast-day:hover {
            background: #e0e7ff;
        }

        .day-header {
            display: flex;
            justify-content: center;
            align-items: baseline;
            gap: 4px;
            margin-bottom: 0px;
        }

        .day-name {
            font-size: 0.9em;
            font-weight: 700;
            color: #1e40af;
        }

        .day-date {
            font-size: 0.7em;
            color: #64748b;
        }

        .weather-emoji {
            font-size: 1.5em;
            margin: 0px 0;
        }

        .weather-desc {
            font-size: 0.72em;
            color: #475569;
            margin-bottom: 6px;
            line-height: 1.2;
            min-height: 2em;
        }

        .temp-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
            font-size: 0.9em;
        }

        .temp-max {
            font-weight: 700;
            color: #dc2626;
        }

        .temp-min {
            font-weight: 600;
            color: #2563eb;
        }

        .temp-separator {
            color: #94a3b8;
            font-weight: 400;
        }

        /* Colorbar styles */
        .colorbar-control {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 10px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            display: flex;
            gap: 10px;
            border: 1px solid #e2e8f0;
            direction: ltr;
        }

        .colorbar-gradient {
            width: 14px;
            height: 200px;
            background: linear-gradient(to top,
                    rgb(0, 0, 255),
                    rgb(0, 255, 255),
                    rgb(0, 255, 0),
                    rgb(255, 255, 0),
                    rgb(255, 0, 0));
            border-radius: 4px;
        }

        .colorbar-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 200px;
            font-size: 11px;
            font-weight: 700;
            color: #334155;
            padding: 2px 0;
            text-align: right;
            min-width: 32px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            font-family: 'Assistant', sans-serif;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 1.1em;
            color: #475569;
            font-weight: 600;
        }

        .error-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fef2f2;
            color: #991b1b;
            padding: 24px 32px;
            border-radius: 12px;
            font-size: 1.1em;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            direction: rtl;
        }

        @media (max-width: 500px) {
            .leaflet-popup-content {
                min-width: 220px;
                max-width: 290px;
            }

            .popup-header {
                font-size: 1em;
                padding: 10px 12px;
            }

            .forecast-grid {
                padding: 4px;
            }

            .forecast-day {
                padding: 6px 2px;
            }

            .weather-emoji {
                font-size: 1.3em;
            }

            .day-name {
                font-size: 0.9em;
            }

            .temp-max {
                font-size: 1em;
            }

            .temp-min {
                font-size: 0.85em;
            }

            .weather-desc {
                font-size: 0.65em;
            }
        }

        .weather-message-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            /* Right side for RTL context usually makes sense to be unobtrusive or accessible? Actually let's put it on the left so it doesn't cover the legend which is bottomleft? Legend is bottomleft. So message box should be bottom right. */
            /* Wait, legend is L.control position 'bottomleft'. */
            /* So I should put message box on bottom RIGHT. */
            left: auto;
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 300px;
            direction: rtl;
            font-size: 0.9em;
            display: none;
            /* Hidden by default until loaded */
        }

        @media (max-width: 500px) {
            .weather-message-box {
                left: 10px;
                right: 10px;
                max-width: none;
                bottom: 10px;
            }
        }

        .weather-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: 700;
            color: #1e40af;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 8px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: #64748b;
            padding: 0 5px;
        }

        .close-btn:hover {
            color: #ef4444;
        }

        .forecast-list-item {
            margin-bottom: 12px;
        }

        .forecast-list-item:last-child {
            margin-bottom: 0;
        }

        .forecast-date {
            font-weight: 600;
            color: #334155;
            display: block;
            margin-bottom: 2px;
        }

        .forecast-text {
            color: #475569;
            line-height: 1.4;
        }
    </style>
</head>

<body>
    <div id="loading" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">×˜×•×¢×Ÿ ×ª×—×–×™×ª...</div>
    </div>

    <!-- Message Box Container -->
    <div id="weather-message-box" class="weather-message-box">
        <div class="weather-message-header">
            <span>×ª×—×–×™×ª ××¨×¦×™×ª</span>
            <button class="close-btn"
                onclick="document.getElementById('weather-message-box').style.display='none'">Ã—</button>
        </div>
        <div id="weather-message-content"></div>
    </div>

    <div id="floating-title" style="flex-direction: row; justify-content: center; gap: 20px;">
        <a href="index.html" class="home-btn">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
            <span>×“×£ ×”×‘×™×ª</span>
        </a>
        <h1 style="margin: 0;">
            <img src="logo.jpg" alt="Icon" class="title-icon">
            ×ª×—×–×™×ª ××–×’ ××•×•×™×¨ - 4 ×™××™×
        </h1>
        <div class="data-source" style="margin-top: 0;">
            <span>× ×ª×•× ×™× ×</span>
            <a href="https://ims.gov.il/en/data_gov" target="_blank" rel="noopener">
                <img src="https://ims.gov.il/themes/imst/ims/images/logo.jpg" alt="IMS" class="ims-logo">
            </a>
        </div>
    </div>
    <div id="map"></div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <script>
        // Initialize map centered on Israel
        const map = L.map('map').setView([31.5, 35.0], 8);

        // Tile layer
        L.tileLayer('https://cdnil.govmap.gov.il/xyz/heb/{z}/{x}/{y}.png', {
            attribution: 'Â© ×”××¨×›×– ×œ××™×¤×•×™ ×™×©×¨××œ www.govmap.gov.il'
        }).addTo(map);

        // Hebrew day-of-week symbols: Sunday=× ... Saturday=×©
        const hebrewDays = ['×', '×‘', '×’', '×“', '×”', '×•', '×©'];
        const openCities = ['×™×¨×•×©×œ×™×', '×ª×œ ××‘×™×‘', '×‘××¨ ×©×‘×¢', '×—×™×¤×”', '××™×œ×ª', '×¦×¤×ª', '××¦×¤×” ×¨××•×Ÿ'];
        let markers = [];
        let firstClick = true;

        // Weather code â†’ emoji mapping
        const weatherEmoji = {
            1010: 'ğŸŒªï¸',  // Sandstorms
            1020: 'â›ˆï¸',   // Thunderstorms
            1060: 'ğŸŒ¨ï¸',  // Snow
            1070: 'ğŸŒ¨ï¸',  // Light Snow
            1080: 'ğŸŒ¨ï¸',  // Sleet
            1140: 'ğŸŒ§ï¸',  // Rainy
            1160: 'ğŸŒ«ï¸',  // Fog
            1220: 'â›…',   // Partly cloudy
            1230: 'â˜ï¸',   // Cloudy
            1250: 'â˜€ï¸',   // Clear
            1260: 'ğŸ’¨',   // Windy
            1270: 'ğŸŒ¡ï¸',  // Muggy
            1300: 'â„ï¸',   // Frost
            1310: 'ğŸ”¥',   // Hot
            1320: 'ğŸ¥¶',   // Cold
            1510: 'ğŸŒŠ',   // Stormy
            1520: 'â„ï¸',   // Heavy Snow
            1530: 'ğŸŒ¤ï¸',  // Partly cloudy possible rain
            1540: 'ğŸŒ¥ï¸',  // Cloudy possible rain
            1560: 'ğŸŒ¦ï¸',  // Cloudy light rain
            1570: 'ğŸ˜¶â€ğŸŒ«ï¸', // Dust
            1580: 'ğŸ”¥',   // Hot Extremely
            1590: 'ğŸ¥¶',   // Extremely Cold
        };

        // Temperature â†’ Jet color gradient (Blue â†’ Cyan â†’ Green â†’ Yellow â†’ Bright Red)
        function tempColor(temp) {
            const t = Math.max(10, Math.min(40, temp));
            const ratio = (t - 10) / 30;
            let r, g, b;

            if (ratio < 0.25) { // Blue (0,0,255) to Cyan (0,255,255)
                r = 0;
                g = Math.round(ratio * 4 * 255);
                b = 255;
            } else if (ratio < 0.5) { // Cyan (0,255,255) to Green (0,255,0)
                r = 0;
                g = 255;
                b = Math.round((0.5 - ratio) * 4 * 255);
            } else if (ratio < 0.75) { // Green (0,255,0) to Yellow (255,255,0)
                r = Math.round((ratio - 0.5) * 4 * 255);
                g = 255;
                b = 0;
            } else { // Yellow (255,255,0) to Bright Red (255,0,0)
                r = 255;
                g = Math.round((1.0 - ratio) * 4 * 255);
                b = 0;
            }
            return `rgb(${r},${g},${b})`;
        }

        // Format date as DD/MM
        function fmtDate(dateStr) {
            const parts = dateStr.split('-');
            return parts[2] + '/' + parts[1];
        }

        // Fetch weather codes CSV, XML forecast data, and Text Forecast
        Promise.all([
            fetch('https://raw.githubusercontent.com/yuval-harpaz/weather/main/data/weather_code.csv').then(r => r.text()),
            fetch('https://quiet-glitter-2b69.yuvharpaz.workers.dev').then(r => r.arrayBuffer()),
            fetch('https://forcastisr4days.yuvharpaz.workers.dev').then(r => r.text())
        ]).then(([codesCsv, xmlBuffer, textForecastXmlStr]) => {
            // Parse weather codes
            const codesData = Papa.parse(codesCsv, { header: true, skipEmptyLines: true }).data;
            const weatherCodes = {};
            codesData.forEach(row => {
                weatherCodes[row.Code] = { he: row['××–×’ ×”××•×•×™×¨'], en: row.Weather };
            });

            // --- Process Text Forecast (Message Box) ---
            try {
                const parser = new DOMParser();
                const textDoc = parser.parseFromString(textForecastXmlStr, 'text/xml');

                // Find Israel location
                const locations = textDoc.querySelectorAll('Location');
                let israelLoc = null;
                for (let i = 0; i < locations.length; i++) {
                    const name = locations[i].querySelector('LocationNameEng').textContent;
                    if (name === 'Israel') {
                        israelLoc = locations[i];
                        break;
                    }
                }

                if (israelLoc) {
                    const timeUnits = israelLoc.querySelectorAll('TimeUnitData');
                    let msgContent = '';
                    let count = 0;

                    timeUnits.forEach(tu => {
                        if (count >= 4) return;

                        const dateStr = tu.querySelector('Date').textContent;
                        const elements = tu.querySelectorAll('Element');
                        let weatherHeb = '';

                        elements.forEach(el => {
                            if (el.querySelector('ElementName').textContent === 'Weather in Hebrew') {
                                weatherHeb = el.querySelector('ElementValue').textContent.trim();
                            }
                        });

                        if (weatherHeb) {
                            const d = new Date(dateStr);
                            if (!isNaN(d.getTime())) {
                                const dayName = hebrewDays[d.getDay()];
                                const formattedDate = fmtDate(dateStr);

                                msgContent += `
                                    <div class="forecast-list-item">
                                        <span class="forecast-date">${dayName}' ${formattedDate}</span>
                                        <div class="forecast-text">${weatherHeb}</div>
                                    </div>
                                `;
                                count++;
                            }
                        }
                    });

                    if (msgContent) {
                        document.getElementById('weather-message-content').innerHTML = msgContent;
                        document.getElementById('weather-message-box').style.display = 'block';
                    }
                }
            } catch (e) {
                console.warn('Error parsing text forecast:', e);
            }

            // Decode ISO-8859-8 (Hebrew)
            const decoder = new TextDecoder('iso-8859-8');
            const xmlText = decoder.decode(new Uint8Array(xmlBuffer));

            // Parse XML
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            const locations = xmlDoc.querySelectorAll('Location');

            const cities = [];

            locations.forEach(loc => {
                const meta = loc.querySelector('LocationMetaData');
                const nameEng = meta.querySelector('LocationNameEng').textContent;
                const nameHeb = meta.querySelector('LocationNameHeb').textContent;
                const lat = parseFloat(meta.querySelector('DisplayLat').textContent);
                const lon = parseFloat(meta.querySelector('DisplayLon').textContent);

                const timeUnits = loc.querySelectorAll('TimeUnitData');
                const days = [];

                timeUnits.forEach(tu => {
                    const date = tu.querySelector('Date').textContent;
                    const elements = tu.querySelectorAll('Element');
                    const dayData = { date };

                    elements.forEach(el => {
                        const name = el.querySelector('ElementName').textContent;
                        const value = el.querySelector('ElementValue').textContent;
                        if (name === 'Maximum temperature') dayData.max = parseInt(value);
                        if (name === 'Minimum temperature') dayData.min = parseInt(value);
                        if (name === 'Weather code') dayData.weatherCode = value;
                    });

                    // Only include days that have at least a weather code or max temp
                    if (dayData.weatherCode || dayData.max !== undefined) {
                        days.push(dayData);
                    }
                });

                // Take up to 4 days that have max temperature
                const forecastDays = days.filter(d => d.max !== undefined).slice(0, 4);

                if (forecastDays.length > 0) {
                    cities.push({ nameEng, nameHeb, lat, lon, days: forecastDays });
                }
            });

            // Add markers
            cities.forEach(city => {
                // Next day's max temp for marker color
                const nextDayMax = city.days[0] ? city.days[0].max : 25;
                const color = tempColor(nextDayMax);

                const marker = L.circleMarker([city.lat, city.lon], {
                    radius: 8,
                    fillColor: color,
                    color: '#fff',
                    weight: 1.5,
                    opacity: 1,
                    fillOpacity: 0.9
                }).addTo(map);

                markers.push({ marker, nameHeb: city.nameHeb, days: city.days });

                // Build forecast HTML
                let forecastHTML = '<div class="forecast-grid">';
                city.days.forEach(day => {
                    const d = new Date(day.date + 'T00:00:00');
                    const daySymbol = hebrewDays[d.getDay()];
                    const emoji = weatherEmoji[day.weatherCode] || 'ğŸŒ¡ï¸';

                    forecastHTML += `
            <div class="forecast-day">
              <div class="day-header">
                <span class="day-name">${daySymbol}</span>
                <span class="day-date">${fmtDate(day.date)}</span>
              </div>
              <div class="weather-emoji">${emoji}</div>
              <div class="temp-row">
                <span class="temp-min">${day.min !== undefined ? day.min : '-'}</span>
                <span class="temp-separator">-</span>
                <span class="temp-max">${day.max !== undefined ? day.max : '-'}</span>
              </div>
            </div>`;
                });
                forecastHTML += '</div>';

                const isPermanent = openCities.some(name => city.nameHeb.includes(name));

                marker.bindTooltip(forecastHTML, {
                    permanent: isPermanent,
                    direction: 'right',
                    className: 'compact-tooltip',
                    offset: [165, 0],
                    opacity: 1,
                    interactive: false,
                    sticky: false
                });

                marker.on('click', function (e) {
                    // Make all markers non-permanent for hover behavior
                    markers.forEach(m => {
                        const tt = m.marker.getTooltip();
                        if (tt) {
                            const content = tt.getContent();
                            m.marker.unbindTooltip();
                            m.marker.bindTooltip(content, {
                                permanent: false,
                                direction: 'right',
                                className: 'compact-tooltip',
                                offset: [165, 0],
                                opacity: 1,
                                interactive: false,
                                sticky: false
                            });
                        }
                    });

                    // Make the clicked marker permanent so it stays open
                    const clickedContent = marker.getTooltip() ? marker.getTooltip().getContent() : forecastHTML;
                    marker.unbindTooltip();
                    marker.bindTooltip(clickedContent, {
                        permanent: true,
                        direction: 'right',
                        className: 'compact-tooltip',
                        offset: [165, 0],
                        opacity: 1,
                        interactive: false,
                        sticky: false
                    });
                    marker.openTooltip();
                    firstClick = false;
                });
            });

            // Add vertical colorbar
            const colorbar = L.control({ position: 'bottomleft' });
            colorbar.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'colorbar-control');
                div.innerHTML = `
                    <div class="colorbar-labels">
                        <span>40Â°C</span>
                        <span>32.5Â°C</span>
                        <span>25Â°C</span>
                        <span>17.5Â°C</span>
                        <span>10Â°C</span>
                    </div>
                    <div class="colorbar-gradient"></div>
                `;
                return div;
            };
            colorbar.addTo(map);

            // Hide loading
            document.getElementById('loading').style.display = 'none';

        }).catch(err => {
            console.error('Error loading forecast data:', err);
            document.getElementById('loading').innerHTML =
                `<div class="error-msg">×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×”×ª×—×–×™×ª<br><small>${err.message}</small></div>`;
        });
    </script>

</body>

</html>